package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"strings"

	"github.com/eternal-flame-AD/gopheR/rcflags"
)

var (
	flagOutput  = flag.String("o", "mkrcall.go", "output file")
	flagDllName = flag.String("n", "", "dll name, leave empty to sue dynamic symbol resolution")
)

var (
	builtInTypeMap = map[string]string{
		"string":  "gopher.String",
		"float64": "gopher.Float64",
		"int64":   "gopher.Int64",
		"bool":    "gopher.Bool",
	}
)

func translateIdent(ident *ast.Ident) string {
	if t, ok := builtInTypeMap[ident.Name]; ok {
		return t
	}
	return ident.Name
}

type Module struct {
	Package   string
	Functions []*Function
}

type Function struct {
	Directive string
	Name      string
	Params    []*Param
	Return    *Param
}

func (f Function) WrapperName() string {
	fields := strings.Fields(f.Directive)
	return fields[0]
}

type Param struct {
	Name string
	Type string
}

func WriteModule(writer io.Writer, module *Module) error {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "//go:build cgo\n")
	fmt.Fprintf(&buf, "// Code generated by mkrcall; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "package %v\n", module.Package)
	fmt.Fprintf(&buf, "\n")
	cflags, ldflags := rcflags.QueryRFlags()
	fmt.Fprintf(&buf, "// #cgo CFLAGS: %s\n", strings.Join(cflags, " "))
	fmt.Fprintf(&buf, "// #cgo LDFLAGS: %s\n", strings.Join(ldflags, " "))
	fmt.Fprintf(&buf, "// #define R_NO_REMAP\n")
	fmt.Fprintf(&buf, "// #include <R.h>\n")
	fmt.Fprintf(&buf, "// #include <Rinternals.h>\n")

	if _, err := io.Copy(writer, &buf); err != nil {
		return err
	}

	for _, f := range module.Functions {
		nargs := len(f.Params)
		fmt.Fprintf(&buf, "// SEXP %s(%s);\n", f.WrapperName(),
			strings.TrimSuffix(
				strings.Repeat("SEXP, ", nargs), ", "))
	}
	fmt.Fprintf(&buf, "import \"C\"\n")
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"unsafe\"\n")
	fmt.Fprintf(&buf, "\tgopher \"github.com/eternal-flame-AD/gopheR\"\n")
	fmt.Fprintf(&buf, ")\n")
	fmt.Fprintf(&buf, "\n")

	if _, err := io.Copy(writer, &buf); err != nil {
		return err
	}

	for _, f := range module.Functions {
		fmt.Fprintf(&buf, "//export %s\n", f.WrapperName())
		fmt.Fprintf(&buf, "func %s(", f.WrapperName())
		for i, _ := range f.Params {
			if i != 0 {
				fmt.Fprintf(&buf, ", ")
			}
			fmt.Fprintf(&buf, "input%d C.SEXP", i)
		}
		fmt.Fprintf(&buf, ") C.SEXP {\n")
		for i, p := range f.Params {
			fmt.Fprintf(&buf, "\tinput%d_sexp := (*gopher.SEXP)(unsafe.Pointer(&input%d))\n", i, i)
			fmt.Fprintf(&buf, "\tinput%d_val := %sFromSEXP(*input%d_sexp)\n", i, translateIdent(&ast.Ident{Name: p.Type}), i)
		}
		fmt.Fprintf(&buf, "\toutput := %s(", f.Name)
		for i := range f.Params {
			if i != 0 {
				fmt.Fprintf(&buf, ", ")
			}
			fmt.Fprintf(&buf, "input%d_val", i)
		}
		fmt.Fprintf(&buf, ")\n")
		if f.Return.Type == "string" {
			fmt.Fprintf(&buf, "\toutput_sexp := gopher.StringToSEXP(output)\n")
		} else if f.Return.Type == "float64" {
			fmt.Fprintf(&buf, "\toutput_sexp := gopher.Float64ToSEXP(output)\n")
		} else if f.Return.Type == "int64" {
			fmt.Fprintf(&buf, "\toutput_sexp := gopher.Int64ToSEXP(output)\n")
		} else if f.Return.Type == "bool" {
			fmt.Fprintf(&buf, "\toutput_sexp := gopher.BoolToSEXP(output)\n")
		} else {
			fmt.Fprintf(&buf, "\toutput_sexp := output.SEXP()\n")
		}
		fmt.Fprintf(&buf, "\treturn *(*C.SEXP)(unsafe.Pointer(&output_sexp))\n")
		fmt.Fprintf(&buf, "}\n\n")
	}

	if _, err := io.Copy(writer, &buf); err != nil {
		return err
	}

	if *flagDllName != "" {

		fmt.Fprintf(&buf, "func R_init_%s(DllInfo *C.DllInfo) {\n", *flagDllName)
		fmt.Fprintf(&buf, "\tcallMethodDef := []C.R_CallMethodDef{\n")
		for _, f := range module.Functions {
			fmt.Fprintf(&buf, "\t\t{C.CString(\"%s\"), (C.DL_FUNC)(C.%s), %d, [4]byte{0,0,0,0}},\n",
				f.WrapperName(), f.WrapperName(), len(f.Params))

		}
		fmt.Fprintf(&buf, "\t}\n")
		fmt.Fprintf(&buf, "\tC.R_registerRoutines(DllInfo, nil, &callMethodDef[0], nil, nil)\n")
		fmt.Fprintf(&buf, "\tC.R_useDynamicSymbols(DllInfo, 0)\n")
		fmt.Fprintf(&buf, "}\n\n")

	}

	if _, err := io.Copy(writer, &buf); err != nil {
		return err
	}

	return nil
}

func ParseInputFile(module *Module, inputFile string) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, inputFile, nil, parser.ParseComments)
	if err != nil {
		return err
	}
	if p := f.Name.String(); module.Package == "" {
		module.Package = p
	} else if p != module.Package {
		return fmt.Errorf("multiple packages: %v, %v", module.Package, p)
	}

	for _, c := range f.Comments {
		text := c.Text()
		if strings.HasPrefix(text, "rcall ") {
			commentText :=
				strings.TrimSpace(
					strings.TrimPrefix(text, "rcall "))
			nextDecl := (ast.Decl)(nil)
			for _, decl := range f.Decls {
				if decl.Pos() > c.Pos() {
					nextDecl = decl
					break
				}
			}
			if nextDecl == nil {
				log.Fatalf("no next decl after comment: %d", c.Pos())
			}
			if funcDecl, ok := nextDecl.(*ast.FuncDecl); ok {
				if funcDecl.Recv != nil {
					log.Fatalf("func decl has receiver: %+v", funcDecl.Recv)
				}
				var params []*Param
				for _, field := range funcDecl.Type.Params.List {
					for _, name := range field.Names {
						if ident, ok := field.Type.(*ast.Ident); ok {
							params = append(params, &Param{
								Name: name.Name,
								Type: ident.String(),
							})
						} else if starExpr, ok := field.Type.(*ast.SelectorExpr); ok {
							params = append(params, &Param{
								Name: name.Name,
								Type: translateIdent(starExpr.X.(*ast.Ident)) + "." + starExpr.Sel.Name,
							})
						} else {
							log.Fatalf("param type is not ident: %+v", field.Type)
						}
					}
				}
				var returnParam *Param
				if funcDecl.Type.Results != nil {
					if len(funcDecl.Type.Results.List) != 1 {
						log.Fatalf("func decl has more than one return value: %+v", funcDecl.Type.Results)
					}
					field := funcDecl.Type.Results.List[0]
					if len(field.Names) != 0 {
						log.Fatalf("func decl has named return value: %+v", field.Names)
					}
					if ident, ok := field.Type.(*ast.Ident); ok {
						returnParam = &Param{
							Type: ident.String(),
						}
					} else if starExpr, ok := field.Type.(*ast.SelectorExpr); ok {
						returnParam = &Param{
							Type: translateIdent(starExpr.X.(*ast.Ident)) + "." + starExpr.Sel.Name,
						}
					} else {
						log.Fatalf("return type is not ident: %+v", field.Type)
					}
				}
				module.Functions = append(module.Functions, &Function{
					Directive: commentText,
					Name:      funcDecl.Name.Name,
					Params:    params,
					Return:    returnParam,
				})
			} else {
				log.Fatalf("next decl after comment is not a func decl: %+v", nextDecl)
			}
		}
	}
	return nil
}

func main() {
	flag.Parse()

	outF, err := os.Create(*flagOutput)
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}

	inputFiles := flag.Args()

	module := &Module{}
	for _, inputFile := range inputFiles {
		if err := ParseInputFile(module, inputFile); err != nil {
			log.Fatalf("failed to parse input file %s: %v", inputFile, err)
		}
	}

	if err := WriteModule(outF, module); err != nil {
		log.Fatalf("failed to write module: %v", err)
	}
}
